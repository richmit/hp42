# -*- Mode:Org; Coding:utf-8; fill-column:158 -*-
#+TITLE:       free42 Programming Tools
#+AUTHOR:      Mitch Richling
#+EMAIL:       http://www.mitchr.me/
#+DATE:        2021-03-19
#+DESCRIPTION: Random stuff to assist with free42/hp-42s/DM42 programing
#+LANGUAGE:    en
#+OPTIONS:     num:t toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t skip:nil d:nil todo:t pri:nil H:5 p:t author:t html-scripts:nil
#+PROPERTY: header-args :eval never-export
#+HTML_HEAD: <style>body { width: 95%; margin: 2% auto; font-size: 18px; line-height: 1.4em; font-family: Georgia, serif; color: black; background-color: white; }</style>
#+HTML_HEAD: <style>body { min-width: 500px; max-width: 1024px; }</style>
#+HTML_HEAD: <style>h1,h2,h3,h4,h5,h6 { color: #A5573E; line-height: 1em; font-family: Helvetica, sans-serif; }</style>
#+HTML_HEAD: <style>h1,h2,h3 { line-height: 1.4em; }</style>
#+HTML_HEAD: <style>h1.title { font-size: 3em; }</style>
#+HTML_HEAD: <style>h4,h5,h6 { font-size: 1em; }</style>
#+HTML_HEAD: <style>.org-src-container { border: 1px solid #ccc; box-shadow: 3px 3px 3px #eee; font-family: Lucida Console, monospace; font-size: 80%; margin: 0px; padding: 0px 0px; position: relative; }</style>
#+HTML_HEAD: <style>.org-src-container>pre { line-height: 1.2em; padding-top: 1.5em; margin: 0.5em; background-color: #404040; color: white; overflow: auto; }</style>
#+HTML_HEAD: <style>.org-src-container>pre:before { display: block; position: absolute; background-color: #b3b3b3; top: 0; right: 0; padding: 0 0.2em 0 0.4em; border-bottom-left-radius: 8px; border: 0; color: white; font-size: 100%; font-family: Helvetica, sans-serif;}</style>
#+HTML_HEAD: <style>pre.example { white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -o-pre-wrap; font-family: Lucida Console, monospace; font-size: 80%; background: #404040; color: white; display: block; padding: 0em; border: 2px solid black; }</style>
#+HTML_LINK_HOME: https://www.mitchr.me/
#+HTML_LINK_UP: https://richmit.github.io/hp42/
#+EXPORT_FILE_NAME: ../docs/hp42s-meta
#+LATEX_HEADER: \usepackage{extsizes} 
#+LATEX_HEADER: \usepackage[landscape,margin=0.5in]{geometry}
#+LATEX_HEADER: \usepackage{mathabx}
#+LATEX_HEADER: \usepackage{boisik}
#+LATEX_CLASS_OPTIONS: [letterpaper, 8pt]
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \DeclareUnicodeCharacter{028F}{\textsc{Y}}
#+LATEX_HEADER: \DeclareUnicodeCharacter{03A3}{$\Sigma$}
#+LATEX_HEADER: \DeclareUnicodeCharacter{03BC}{$\mu$}
#+LATEX_HEADER: \DeclareUnicodeCharacter{03C0}{\pi}
#+LATEX_HEADER: \DeclareUnicodeCharacter{1D07}{$\bagmember$}
#+LATEX_HEADER: \DeclareUnicodeCharacter{21B5}{$\dlsh$}
#+LATEX_HEADER: \DeclareUnicodeCharacter{221A}{\makebox[.5em]{$\sqrt{}$}}
#+LATEX_HEADER: \DeclareUnicodeCharacter{2221}{$\measuredangle$}
#+LATEX_HEADER: \DeclareUnicodeCharacter{222B}{$\int$}
#+LATEX_HEADER: \DeclareUnicodeCharacter{2260}{$\neq$}
#+LATEX_HEADER: \DeclareUnicodeCharacter{2264}{$\leq$}
#+LATEX_HEADER: \DeclareUnicodeCharacter{2265}{$\geq$}
#+LATEX_HEADER: \DeclareUnicodeCharacter{251C}{$\vdash$}
#+LATEX_HEADER: \DeclareUnicodeCharacter{2592}{$\square$}
#+LATEX_HEADER: \DeclareUnicodeCharacter{25B8}{$\blacktriangleright$}

#+ATTR_HTML: :border 2 solid #ccc :frame hsides :align center
|        <r> | <l>                                          |
|  *Author:* | /{{{author}}}/                               |
| *Updated:* | /{{{modification-time(%Y-%m-%d %H:%M:%S)}}}/ |
#+ATTR_HTML: :align center
Copyright {{{time(%Y)}}} Mitch Richling. All rights reserved.

#+TOC: headlines 5

#        #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #
#   00   #    10   #    20   #    30   #    40   #    50   #    60   #    70   #    80   #    90   #   100   #   110   #   120   #   130   #   140   #   150   #   160   #
# 234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789
#        #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #
#        #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #

* Metadata

The home for this HTML file is: https://richmit.github.io/hp42/hp42s-meta.html

Files related to this document may be found on github: https://github.com/richmit/hp42

Directory contents:
#+ATTR_HTML: :border 0 :frame none :rules none :align center
   | =src=     | - | The org-mode file that generated this HTML document            |
   | =src_42s= | - | Ready to convert source listings for 42s code in this document |
   | =docs=    | - | This html document and associated PDF                          |
   | =bin=     | - | Importable RAW program files                                   |

* Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:

This org-mode document contains various tools (mostly for Emacs) that help me write programs for the 42s:

   - Elisp function to generate 42s menu programs
   - A tool to insert free42 utf-8 characters given a list of character numbers
   - Elisp function to generate custom menus (menus of built-in functions and global labels)
   - yasnippet templates to help type code
   - ElISP Code to translate my code listings into code for free42 & MD42
   - 42s notes
     - free42 utf-8 characters with character numbers

* Generating 42s menu code
:PROPERTIES:
:CUSTOM_ID: menu-gen
:END:

** Generic menu generator

This code will read an org-mode table describing a menu, and generate 42s code to implement the menu.  The only limitation on menu depth and size are the
number of available two digit labels.  

#+ATTR_HTML: :align center
| Line | Menu alpha strings | Menu targets | Some Data | Some More Data |
|------+--------------------+--------------+-----------+----------------|
|    1 | foo:bar:foobar     |              | marry     | red            |
|    2 | foo:bar:LBL 77     | LBL 87       | had a     | blue           |
|    3 | foo:bar:LBL 78     | fooboo       | little    | yellow         |
|    4 | foo:bar:LBL 78     |              | lamb      | green          |


One column of the table is used to define the /menu alpha strings/. The table above provides an example.  The string =foo:bar:foobar= (table line 1)
defines a top level button named =foo= that leads to a menu containing another menu named =bar= which contains an /action/ key named =foobar=.  The final
component, =foobar= in this example, is used for the alpha string for the menu key.  It is used as-is with one exception.  That exception occurs when the
final component looks like "=LBL NN=" where =NN= is a two digit number (table line 2).  In this case the local label will be =XEQ='ed just before the call to
=KEY=.  This allows the key's alpha string to be dynamically generated by a subroutine at run time.  If this subroutine returns =RETNO= then the menu key's
=KEY= command will be skipped.  In this way one can dynamically decide if a menu key should be active or not.  If the key string is "" (empty) or "▒▒▒▒", then
a blank key will be placed in the menu.

Now that we know how the menu key strings are constructed, what about the =GTO/XEQ= target for the generated =KEY= commands?  The following
rules are applied with the first one matching being used:

#+ATTR_HTML: :align center
|--------------------+-----------------+------------+---------------+----------------------|
| =gen-target-label= | =target-column= | /Menu Key/ | /Menu Target/ | The =XEQ/GTO= Target |
|--------------------+-----------------+------------+---------------+----------------------|
| =nil=              | =nil=           | "=LBL NN=" | N/A           | Auto-generated       |
| =nil=              | =nil=           | N/A        | N/A           | Menu key string      |
|--------------------+-----------------+------------+---------------+----------------------|
| =nil=              | non-=nil=       | "=LBL NN=" | "" (empty)    | Auto-generated       |
| =nil=              | non-=nil=       | N/A        | "" (empty)    | Menu key string      |
| =nil=              | non-=nil=       | N/A        | "=LBL NN="    | =NN=                 |
| =nil=              | non-=nil=       | N/A        | N/A           | Menu target          |
|--------------------+-----------------+------------+---------------+----------------------|
| non-=nil=          | N/A             | N/A        | N/A           | See next table       |
|--------------------+-----------------+------------+---------------+----------------------|

When =gen-target-label= is non-=nil=, the return value of the function determines the target.  If the return is =nil=, then the label is auto-generated.
Otherwise the returned string is used.  Note the returned string must contain embedded quotes if it is a global label target.

In general this might be summarized as follows: When =gen-target-label= is non-=nil=, the target is determined by the =gen-target-label= function.  When
=gen-target-label= is =nil=, then the menu target column is used unless it is empty, and then the menu key is used.

When a local label is generated, the subroutine for that label will also be generated.  The content of that subroutine can be provided by calling the a user
provided function via the =gen-target-code= argument.  This allows the *entire* program to be generated from the contents of the table my [[https://richmit.github.io/hp42/cons.html][constants]] & [[https://richmit.github.io/hp42/unit.html][units]]
programs are good examples.  Note that if all the lables are generated, then the resulting program is ended with an =END= instruction.  

# This
# mode of operation supports an "litterate programming" methodology where one can /tangle/ code blocks in the org-document together to produce a complete
# program.

Note the Unicode point 166 (the "¦" character) is automatically converted to the pipe character ("|").  This lets you include the 42s pipe symbol in org-mode
tables.

=MJR-generate-42-menu-code= arguments:
 - =top-lab=                 :: The global label to use for the generated program
 - =numeric-lbl-start=       :: Beginning for a range of local numeric labels that will be used for the program
 - =tbl=                     :: The org-mode table with the menu description
 - =menu-alpha-column=       :: The column with the menu alpha strings
 - =menu-exit-behavior=      :: What to do when =[EXIT]= is pressed.
    - ='exit=: Exit the application
    - ='up=: Return to parent menu or exit if no parent
 - =after-leaf-action=       :: What do do when a /action/ menu is used (a leaf node in the menu)
    - ='stay=: Keep the menu active
    - ='exit=: Exit the menu
 - =include-end=             :: Include final =END= statement
    - ='yes=: Create final =END= statement
    - ='exit=: Do not create final =END= statement
    - ='auto=: Create final =END= statement if all menu target labels were generated
 - =target-column=           :: nil means no target column.  
 - =gen-target-label=        :: A function that generates the label for the =KEY= commands =GTO=/=XEQ=.  Return =nil= for autogen.
   - Arguments: autoish-target, list of row data
   - autoish-target is essentially the target that would have been used if =gen-target-label= were =nil=.  Local labels look like "=LBL NN=" and global ones look like "=FOO=".
 - =gen-target-code=         :: A function that generates the code for the /action/.  It gets a list that contains the table row for the menu item.
   - Arguments: autoish-target, menu target label, list of row data

#+BEGIN_SRC elisp :results silent
(defun MJR-generate-42-menu-code (top-lab 
                                  numeric-lbl-start
                                  tbl
                                  menu-alpha-column
                                  target-column
                                  after-leaf-action
                                  menu-exit-behavior
                                  include-end
                                  gen-target-label
                                  gen-target-code)
  (let* ((no-local 't)
         (min-free-lab (+ numeric-lbl-start 2))
         (m-code "")
         (x-code ""))
    (cl-labels ((add-m-code (a) (setq m-code (concat m-code a "\n")))
                (add-x-code (a) (setq x-code (concat x-code a "\n")))
                (prc-mnu (menu)
                         (if (or (not (listp menu))
                                 (null (cdr menu)))
                             menu
                             (mapcar #'prc-mnu
                                     (append (list (car menu))
                                             (reverse
                                              (cl-reduce
                                               (lambda (result cur-elt)
                                                 (let ((last-elt (cl-first result)))
                                                   (if (and (listp last-elt)
                                                            (cdr last-elt)
                                                            (cdr cur-elt)
                                                            (string-equal (cl-first last-elt) (cl-first cur-elt)))
                                                       (progn (nconc (cl-first result) (list (cdr cur-elt)))
                                                              result)
                                                       (if (cdr cur-elt)
                                                           (append (list (list (cl-first cur-elt) (cdr cur-elt)))
                                                                   result)
                                                           (append (list (cl-first cur-elt))  result)))))
                                               (cdr menu)
                                               :initial-value ()))))))
                (gen-mnu (parent-lbl lbl menu)
                         (let* ((num-menu-keys (1- (length menu)))
                                (num-menu-page (ceiling (/ num-menu-keys 6.0)))
                                (page-labs     (cl-loop repeat num-menu-page
                                                        for i = lbl then min-free-lab
                                                        collect i
                                                        when (not (= i lbl))
                                                        do (cl-incf min-free-lab)))
                                (rec-key-labs     nil)
                                (rec-pag-labs     nil))
                           (if (= parent-lbl numeric-lbl-start)
                               (add-m-code (format "LBL \"%s\"" (cl-first menu))))
                           (cl-loop for mkey-elt in (cdr menu)
                                    for mkey-num from 0
                                    for page-num = (truncate (/ mkey-num 6))
                                    for page-key = (mod mkey-num 6)
                                    for mkey-str = (if (vectorp mkey-elt) (aref mkey-elt 0) (cl-first mkey-elt))
                                    for is-leaf  = (vectorp mkey-elt)
                                    for auto-trg = (and is-leaf 
                                                        (or (if target-column 
                                                                (let ((tmp (nth target-column (aref mkey-elt 1))))
                                                                  (if (not (string-empty-p tmp))
                                                                      tmp)))
                                                            (if (not (string-match-p "^LBL [0-9][0-9]$" mkey-str))
                                                                mkey-str)
                                                            ""))
                                    for mkey-trg = (and is-leaf
                                                        (if gen-target-label
                                                            (funcall gen-target-label auto-trg (aref mkey-elt 1))
                                                            (and (not (string-empty-p auto-trg))
                                                                 (if (string-match-p "^LBL [0-9][0-9]$" auto-trg)
                                                                     (substring auto-trg 4)
                                                                     (format "\"%s\"" auto-trg)))))
                                    ;;do (print (format "mkey-str: %s    auto-trg: %s    mkey-trg: %s" mkey-str auto-trg mkey-trg))
                                    when (= page-key 0)
                                    do (progn (add-m-code (format "LBL %02d            @@@@ Page %d of menu %s"
                                                                   (nth page-num page-labs)
                                                                   (1+ page-num)
                                                                   (cl-first menu)))
                                              (add-m-code "CLMENU"))
                                    when (not (or (string-empty-p mkey-str) (string-equal mkey-str "▒▒▒▒")))
                                    do (progn (if (string-match-p "^LBL [0-9][0-9]$" mkey-str)
                                                  (progn (add-m-code (format "XEQ %s" (substring mkey-str 4)))
                                                         (setq no-local nil))
                                                  (add-m-code (format "\"%s\"" mkey-str)))
                                              (if (or (not is-leaf) (not mkey-trg))
                                                  (add-m-code (format "KEY %d %s %02d" 
                                                                       (1+ page-key) 
                                                                       (if is-leaf "XEQ" "GTO") 
                                                                       min-free-lab))
                                                  (progn 
                                                    (add-m-code (format "KEY %d XEQ %s" (1+ page-key) mkey-trg))
                                                    (setq no-local nil)))
                                              (if (and (not mkey-trg) is-leaf)
                                                  (progn (add-x-code (format 
                                                                      "LBL %02d    @@@@ Action for menu key %s" 
                                                                      min-free-lab
                                                                      mkey-str))
                                                         (if gen-target-code 
                                                             (add-x-code (funcall gen-target-code
                                                                                  auto-trg 
                                                                                  mkey-trg
                                                                                  (aref mkey-elt 1)))
                                                             (add-x-code (format "@@@@ TODO: Code for %s!" 
                                                                                  mkey-str)))
                                                         (add-x-code "RTN")))
                                              (push min-free-lab rec-key-labs)
                                              (if (not mkey-trg)
                                                  (cl-incf min-free-lab))
                                              (push (nth page-num page-labs) rec-pag-labs))
                                    when (or (= page-key 5) (= mkey-num (1- num-menu-keys)))
                                    do (progn (if (< 1 num-menu-page)
                                                  (progn (add-m-code (format "KEY 7 GTO %02d" 
                                                                              (nth (mod (1- page-num) 
                                                                                        num-menu-page) 
                                                                                   page-labs)))
                                                         (add-m-code (format "KEY 8 GTO %02d"
                                                                              (nth (mod (1+ page-num) 
                                                                                        num-menu-page) 
                                                                                   page-labs)))))
                                              (if (string-equal menu-exit-behavior "up")
                                                  (add-m-code (format "KEY 9 GTO %02d" parent-lbl))
                                                  (add-m-code (format "KEY 9 GTO %02d" 0)))
                                              (add-m-code "MENU")
                                              (add-m-code "STOP")
                                              (if (string-equal after-leaf-action "stay")
                                                  (add-m-code (format "GTO %02d" (nth page-num page-labs)))
                                                  (add-m-code (format "GTO %02d" 0)))))
                           (cl-loop for mkey-elt in (cdr menu)
                                    for m-lab in (reverse rec-key-labs)
                                    for p-lab in (reverse rec-pag-labs)
                                    when (listp mkey-elt)
                                    do (gen-mnu p-lab m-lab mkey-elt)))))
      (gen-mnu numeric-lbl-start 
               (1+ numeric-lbl-start)
               (prc-mnu (append (list top-lab) (cl-loop for row in tbl
                                                        for row-strs = (mapcar (lambda (x) (replace-regexp-in-string "¦" "|" (format "%s" x)  't 't)) 
                                                                               row)
                                                        for n from 0
                                                        for menu-parts = (split-string 
                                                                          (nth menu-alpha-column row-strs) 
                                                                          ":")
                                                        do (setf (car (last menu-parts))
                                                                 (vector (car (last menu-parts)) row-strs))
                                                        collect menu-parts))))
      (add-m-code (format "LBL %02d @@@@ Application Exit" numeric-lbl-start))
      (add-m-code "EXITALL")
      (add-m-code "RTN") 
      (if (< 100 min-free-lab)
          (error "ERROR: Too many local labels: %d" min-free-lab)))
    (princ (format "%s (ref:%s)\n" (make-string 80 ?@)  top-lab))
    (princ (format "@@@@ DSC: Auto-generated menu program\n"))
    (princ m-code)
    (princ x-code)
    (princ (format "@@@@ Free labels start at: %d\n" min-free-lab))
    (if (or (string-equal include-end "yes") (and (string-equal include-end "auto") no-local))
        (princ "END"))))
#+END_SRC

** For CUSTOM-type Menus

These functions are useful for CUSTOM-type menus -- that is menus that call other programs or built in functions.  I use this as a way to add hierarchy to the
built in CUSTOM menu.  Example:

#+ATTR_HTML: :align center
| Menu   | Prog |
|--------+------|
| LN     |      |
| log    | LOG  |
| MYPROG |      |

In the first line "=LN=" is the menu name and function called.  In the second line "=log=" is the menu name, and "=LOG=" is the function called.  In the third
line "=MYPROG=" is the name of a program -- the code below figures out if a thing is a built in function or a program and uses =XEQ= for programs.  Note that
I may have missed a built in function, so you may have to add one to the list. ;)

If the menu is of the for "LBL NN", then it will be =XEQ='ed to get the menu label.  If the prog is of the form "LBL NN", then it will be =XEQ='ed directly.
If any menu or prog is a label, then an =END= will not be generated at the end of the listing -- this allows one to put the local subroutines later in
the org-mode file and the whole thing will then be tangled together into one program.

#+BEGIN_SRC elisp :results silent
(defun MJR-is-42-builtin (astring) (cl-position astring 
                                                '("%" "%CH" "+" "+/-" "-" "1/X" "10↑X" "ABS" "ACOS" "ACOSH" "ADV" "AGRAPH" "AIP" "ALENG" "ALL" "ALLΣ" "AND" "AOFF" "AON"
                                                  "ARCL" "AROT" "ASHF" "ASIN" "ASINH" "ASSIGN" "ASTO" "ATAN" "ATANH" "ATOX" "AVIEW" "BASE+" "BASE+/-" "BASE-" "BASE×"
                                                  "BASE÷" "BEEP" "BEST" "BINM" "BIT?"  "BIT?"  "CF" "CLA" "CLD" "CLKEYS" "CLLCD" "CLMENU" "CLP" "CLRG" "CLST" "CLV"
                                                  "CLX" "CLΣ" "COMB" "COMPLEX" "CORR" "COS" "COSH" "CPX?"  "CPXRES" "CROSS" "CUSTOM" "DECM" "DEG" "DELAY" "DELR"
                                                  "DET" "DIM" "DIM?"  "DOT" "DSE" "EDIT" "EDITN" "END" "ENG" "ENTER" "EXITALL" "EXPF" "E↑X" "E↑X-1" "FC?"  "FC?C"
                                                  "FCSTX" "FCSTY" "FIX" "FNRM" "FP" "FS?"  "FS?C" "FUNC" "GAMMA" "GETKEY" "GETM" "GRAD" "GROW" "GTO" "HEXM" "HMS+"
                                                  "HMS-" "I+" "I-" "INDEX" "INPUT" "INSR" "INTEG" "INVRT" "IP" "ISG" "J+" "J-" "KEY" "KEYASN" "L4STK" "LASTX" "LBL"
                                                  "LCLBL" "LINF" "LINΣ" "LN" "LN1+X" "LOG" "LOGF" "LSTO" "MAN" "MAT?"  "MEAN" "MENU" "MOD" "MVAR" "N!"  "NEWMAT"
                                                  "NOP" "NORM" "NOT" "OCTM" "OFF" "OLD" "ON" "OR" "PERM" "PGMINT" "PGMSLV" "PIXEL" "POLAR" "POSA" "PRA" "PRLCD"
                                                  "PROFF" "PROMPT" "PRON" "PRSTK" "PRUSR" "PRV" "PRX" "PRΣ" "PSE" "PUTM" "PWRF" "R<>R" "RAD" "RAN" "RCL" "RCL+"
                                                  "RCL-" "RCLEL" "RCLIJ" "RCL×" "RCL÷" "RDX," "RDX."  "REAL?"  "REALRES" "RECT" "RND" "RNRM" "ROTXY" "RSUM" "RTN"
                                                  "RTNERR" "RTNYES" "RTNNO" "R↑" "R↓" "SCI" "SDEV" "SEED" "SF" "SIGN" "SIN" "SINH" "SIZE" "SLOPE" "SOLVE" "SQRT"
                                                  "STO" "STO+" "STO-" "STOEL" "STOIJ" "STOP" "STO×" "STO÷" "STR?"  "SUM" "TAN" "TANH" "TONE" "TRACE" "TRANS" "UVEC"
                                                  "VARMENU" "VIEW" "WMEAN" "WRAP" "WSIZE?"  "X<0?"  "X<>" "X<>Y" "X<Y?"  "X=0?"  "X=Y?"  "X>0?"  "X>Y?"  "XEQ" "XTOA"
                                                  "X↑2" "X≠0?"  "X≠Y?"  "X≤0?"  "X≤Y?"  "X≥0?"  "X≥Y?"  "X≥Y?"  "YINT" "Y↑X" "[FIND]" "[MAX]" "[MIN]" "×" "÷" "Σ+"
                                                  "Σ-" "ΣREG" "ΣREG?"  "←" "↑" "→" "→DEC" "→DEG" "→HMS" "→HR" "→OCT" "→POL" "→RAD" "→REC" "↓" "DDAYS" "DOW" "CLK12"
                                                  "CLK24" "DMY" "MDY" "YMD" "DATE" "TIME" "DATE+" "PI" "WSIZE" "BSIGNED" "BWRAP" "XOR")
                                                :test #'string-equal))

(defun MJR-custom-gen-lab (atrg row) (if (not (MJR-is-42-builtin atrg))
                                         (if (string-match-p "^LBL [0-9][0-9]$" atrg)
                                             (substring auto-trg 4)
                                             (message "\"%s\"" atrg))))

(defun MJR-custom-gen-sub (atrg target row) (message "%s" atrg))
#+END_SRC

** Always generate local lables

This function is handy when you want to always generate local labels.

#+BEGIN_SRC elisp :results silent
(defun MJR-local-only-gen-lab (atrg row) nil)
#+END_SRC

** Test Table For =MJR-generate-42-menu-code=                                                          :noexport:

#+ATTR_HTML: :align center
#+NAME: menu
| Menu 1   | Menu 2 | Targ | Data 1 | Data 2 | Menu 2   |
|----------+--------+------+--------+--------+----------|
| a        | a      |      |      1 | A      | A        |
| TAN      | TAN    |      |      2 | B      | B        |
| TAN      | TAN    | COS  |   3.14 | B      | B        |
| c:d      | c:d    |      |      3 | D      | C:D      |
| c:e      | c:e    |      |      4 | E      | C:D      |
| c:f:     | c:f:   |      |      5 | G      | C:F:     |
| c:f:h    | c:f:h  |      |      6 | H      | C:F:H    |
| i        | i      |      |      7 | I      | I        |
| j        | j      |      |      8 | I      | J        |
| n:LBL 89 | n:m    |      |     12 | N      | N:LBL 79 |
| LBL 88   | p      |      |     13 | O      | LBL 73   |

#+BEGIN_SRC elisp :var tbl=menu :colnames y :results output verbatum :wrap "src hp42s :eval never :tangle no"
(MJR-generate-42-menu-code "PROG_NAME" 0 tbl 1 nil 'stay 'up 'auto #'MJR-local-only-gen-lab nil)
#+END_SRC

#+RESULTS:
#+begin_src hp42s :eval never :tangle no
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ (ref:PROG_NAME)
@@@@ DSC: Auto-generated menu program
LBL "PROG_NAME"
LBL 01            @@@@ Page 1 of menu PROG_NAME
CLMENU
"a"
KEY 1 XEQ 03
"TAN"
KEY 2 XEQ 04
"TAN"
KEY 3 XEQ 05
"c"
KEY 4 GTO 06
"i"
KEY 5 XEQ 07
"j"
KEY 6 XEQ 08
KEY 7 GTO 02
KEY 8 GTO 02
KEY 9 GTO 00
MENU
STOP
GTO 01
LBL 02            @@@@ Page 2 of menu PROG_NAME
CLMENU
"n"
KEY 1 GTO 09
"p"
KEY 2 XEQ 10
KEY 7 GTO 01
KEY 8 GTO 01
KEY 9 GTO 00
MENU
STOP
GTO 02
LBL 06            @@@@ Page 1 of menu c
CLMENU
"d"
KEY 1 XEQ 11
"e"
KEY 2 XEQ 12
"f"
KEY 3 GTO 13
KEY 9 GTO 01
MENU
STOP
GTO 06
LBL 13            @@@@ Page 1 of menu f
CLMENU
"h"
KEY 2 XEQ 14
KEY 9 GTO 06
MENU
STOP
GTO 13
LBL 09            @@@@ Page 1 of menu n
CLMENU
"m"
KEY 1 XEQ 15
KEY 9 GTO 02
MENU
STOP
GTO 09
LBL 00 @@@@ Application Exit
EXITALL
RTN
LBL 03    @@@@ Action for menu key a
@@@@ TODO: Code for a!
RTN
LBL 04    @@@@ Action for menu key TAN
@@@@ TODO: Code for TAN!
RTN
LBL 05    @@@@ Action for menu key TAN
@@@@ TODO: Code for TAN!
RTN
LBL 07    @@@@ Action for menu key i
@@@@ TODO: Code for i!
RTN
LBL 08    @@@@ Action for menu key j
@@@@ TODO: Code for j!
RTN
LBL 10    @@@@ Action for menu key p
@@@@ TODO: Code for p!
RTN
LBL 11    @@@@ Action for menu key d
@@@@ TODO: Code for d!
RTN
LBL 12    @@@@ Action for menu key e
@@@@ TODO: Code for e!
RTN
LBL 14    @@@@ Action for menu key h
@@@@ TODO: Code for h!
RTN
LBL 15    @@@@ Action for menu key m
@@@@ TODO: Code for m!
RTN
@@@@ Free labels start at: 16
END
#+end_src

* Emacs Helper Stuff

The elisp file =hp42s-mode.el= provides few things:
 - A language mode for free42 code -- mostly just provides syntax highlighting
 - =MJR-ins42char=: Lisp function to insert characters given a list of character codes
 - =MJR-dired-org-export=: Lisp function to export to HTML and tangle all marked files in a dired buffer
 - =MJR-process-buffer-as-42s-code=: Lisp function to process *all free42 code in a buffer* for pasting into free42
 - =MJR-target-free42-version=: Variable used by =MJR-process-buffer-as-42s-code= & =MJR-copy-42s-code-in-region= to control version of free42
 - =MJR-copy-42s-code-in-region=: Lisp function that process marked region for pasting into free42 and puts the test on the kill ring -- like =MJR-process-buffer-as-42s-code= but for a region.

To activate the functionality, simply =load= the =hp42s-mode.el= file into emacs.  You can evaluate teh folloing block to do that:

#+BEGIN_SRC elisp :results output silent
(load-file "../emacs/hp42s-mode.el")
#+END_SRC

** Prepare Code For Conversion

I include comments like =@@##= that I use like compiler directives in C.  They provide a way to remove lines of code that are incompatible or unnecessary for
the target version of free42.  It's a bit of a hack, but it lets me maintain one program for diff-rent versions of free42.  When I "tangle" an =org-mode=
buffer, the code is automatically filtered for the selected version of free42 (set via =MJR-target-free42-version=).

#+ATTR_HTML: :border 2 :frame box :rules all :align center
|------------------------+---------------|
| DM42 Version           | Target Free42 |
|------------------------+---------------|
| DMCP 3.26 / DM42 v3.24 |         3.2.6 |
| DMCP 3.25 / DM42 v3.23 |         3.1.8 |
| DMCP 3.22 / DM42 v3.20 |         3.0.5 |
| DMCP 3.21 / DM42 v3.18 |         3.0.2 |
| DMCP-3.20 / DM42-3.17  |        2.5.20 |
| DMCP-3.20 / DM42-3.16  |        2.5.20 |
| DMCP 3.18 / DM42 v3.15 |        2.5.16 |
|------------------------+---------------|

** Automatically processing tangled code

By adding =MJR-process-buffer-as-42s-code= to the =org-babel-post-tangle-hook=, you can automatically process tangled code.  You can do that by evaluating
the next block:

#+BEGIN_SRC elisp :results output silent
(add-hook 'org-babel-post-tangle-hook 'MJR-process-buffer-as-42s-code)
#+END_SRC

A handy way to tangle a file, or files in dired, is the =MJR-org-export-der= in my =.emacs= file.

** Tangle & Load Tangled File

#+BEGIN_SRC elisp :results output silent
(defun MJR-tangle-and-load ()
  "Tangles current file and attempts to load the tangled file.
The tangled file is determiend by looking backward for a :tangle argument."
  (interactive)
  (save-excursion (org-babel-tangle)
                  (if (re-search-backward ":tangle[[:blank:]]+\\([^[:blank:]]+.hp42s\\)$" nil t)
                      (let ((file-name (match-string 1)))
                        (if (or (string-equal "yes" file-name) (string-equal "no" file-name))
                            (message "No explicit tangle file specified")
                            (find-file file-name))))))
#+END_SRC

** yas templates

#+BEGIN_SRC sh :results output verbatum :wrap "src snippet :eval never"
echo ''
for f in ~/core/yasnippet/hp42s-mode/*; do cat $f; echo ''; done
#+END_SRC

#+RESULTS:
#+begin_src snippet :eval never

# -*- mode: snippet -*-
# name: if-then-end
# key: if
# --
...?   @@@@ IF-BEGIN ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))})
GTO ${1:1$(format "%02d" (string-to-number yas-text))}
GTO ${1:$(format "%02d" (+ 1 (string-to-number yas-text)))}
LBL $1 @@@@ IF-THEN ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))})
@@@@ True Code ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))})
LBL ${1:$(format "%02d" (+ 1 (string-to-number yas-text)))} @@@@ IF-END ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))})

# -*- mode: snippet -*-
# name: if-then-else-end
# key: ife
# --
...?   @@@@ IF-BEGIN ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))}/${1:$(format "%02d" (+ 2 (string-to-number yas-text)))})
GTO ${1:1$(format "%02d" (string-to-number yas-text))}
GTO ${1:$(format "%02d" (+ 1 (string-to-number yas-text)))}
LBL $1 @@@@ IF-THEN ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))}/${1:$(format "%02d" (+ 2 (string-to-number yas-text)))})
@@@@ True Code ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))}/${1:$(format "%02d" (+ 2 (string-to-number yas-text)))})
GTO ${1:$(format "%02d" (+ 2 (string-to-number yas-text)))}
LBL ${1:$(format "%02d" (+ 1 (string-to-number yas-text)))} @@@@ IF-ELSE ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))}/${1:$(format "%02d" (+ 2 (string-to-number yas-text)))})
@@@@ False Code ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))}/${1:$(format "%02d" (+ 2 (string-to-number yas-text)))})
LBL ${1:$(format "%02d" (+ 2 (string-to-number yas-text)))} @@@@ IF-END ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))}/${1:$(format "%02d" (+ 2 (string-to-number yas-text)))})

# -*- mode: snippet -*-
# name: if-not-then-end
# key: ifn
# --
...?   @@@@ IF-NOT-BEGIN ($1)
GTO ${1:1$(format "%02d" (string-to-number yas-text))}
@@@@ False Code ($1)
LBL $1 @@@@ IF-NOT-END ($1)

# -*- mode: snippet -*-
# name: if-then-end-return
# key: ifr
# --
...?      @@@@ IF-BEGIN ($1)
GTO ${1:1$(format "%02d" (string-to-number yas-text))}    @@@@ IF-FALSE-BEGIN ($1)
@@@@ False Code ($1)
RTN       @@@@ IF-FALSE-END ($1)
LBL $1    @@@@ IF-TRUE-BEGIN ($1)
@@@@ True Code ($1)
RTN       @@@@ IF-TRUE-END ($1)

#+end_src

* free42 Notes
** Character Set

#+BEGIN_SRC text :eval never
   0 ÷
   1 ×
   2 √
   3 ∫
   4 ▒
   5 Σ
   6 ▸
   7 π
   8 ¿
   9 ≤
  10 [LF]
  11 ≥
  12 ≠
  13 ↵
  14 ↓
  15 →
  16 ←
  17 μ
  18 £
  19 °
  20 Å
  21 Ñ
  22 Ä
  23 ∡
  24 ᴇ
  25 Æ
  26 …
  27 [ESC]
  28 Ö
  29 Ü
  30 ▒
  31 •
  32 [SPACE]
  33 !
  34 "
  35 #
  36 $
  37 %
  38 &
  39 '
  40 (
  41 )
  42 *
  43 +
  44 ,
  45 -
  46 .
  47 /
  48 0
  49 1
  50 2
  51 3
  52 4
  53 5
  54 6
  55 7
  56 8
  57 9
  58 :
  59 ;
  60 <
  61 =
  62 >
  63 ?
  64 @
  65 A
  66 B
  67 C
  68 D
  69 E
  70 F
  71 G
  72 H
  73 I
  74 J
  75 K
  76 L
  77 M
  78 N
  79 O
  80 P
  81 Q
  82 R
  83 S
  84 T
  85 U
  86 V
  87 W
  88 X
  89 Y
  90 Z
  91 [
  92 \
  93 ]
  94 ↑
  95 _
  96 `
  97 a
  98 b
  99 c
 100 d
 101 e
 102 f
 103 g
 104 h
 105 i
 106 j
 107 k
 108 l
 109 m
 110 n
 111 o
 112 p
 113 q
 114 r
 115 s
 116 t
 117 u
 118 v
 119 w
 120 x
 121 y
 122 z
 123 {
 124 |
 125 }
 126 ~
 127 ├
 128 :
 129 ʏ
#+END_SRC

** Date format

#+ATTR_HTML: :align center
| Flag 67 | Flag 31 | Mode |
|---------+---------+------|
| Set     | N/A     | Y.MD |
| Clear   | Clear   | M.DY |
| Clear   | Set     | D.MY |

** Stats registers

| Register   | Contents |
|------------+----------|
| ΣREG? +  0 | Σx       |
| ΣREG? +  1 | Σx^2     |
| ΣREG? +  2 | Σy       |
| ΣREG? +  3 | Σy^2     |
| ΣREG? +  4 | Σxy      |
| ΣREG? +  5 | n        |
| ΣREG? +  6 | Σlnx     |
| ΣREG? +  7 | Σ(lnx)^2 |
| ΣREG? +  8 | Σlny     |
| ΣREG? +  9 | Σ(lny)^2 |
| ΣREG? + 10 | Σlnxlny  |
| ΣREG? + 11 | Σxlny    |
| ΣREG? + 12 | Σylnx    |

* DM 42 Notes

** Display

GrMod is a read write variable.
   - 0 = standard HP-42S resolution 131x16
   - 2 = DM42 full resolution 200x120
   - 3 = DM42 full resolution 400x240

ResX & ResY are read only variables that have the display resolution

* WORKING                                                          :noexport:

#+BEGIN_SRC text :eval never
:::::::::::::::::::::::'##:::::'##::::'###::::'########::'##::: ##:'####:'##::: ##::'######::::::::::::::::::::::::
::::::::::::::::::::::: ##:'##: ##:::'## ##::: ##.... ##: ###:: ##:. ##:: ###:: ##:'##... ##:::::::::::::::::::::::
::::::::::::::::::::::: ##: ##: ##::'##:. ##:: ##:::: ##: ####: ##:: ##:: ####: ##: ##:::..::::::::::::::::::::::::
::::::::::::::::::::::: ##: ##: ##:'##:::. ##: ########:: ## ## ##:: ##:: ## ## ##: ##::'####::::::::::::::::::::::
::::::::::::::::::::::: ##: ##: ##: #########: ##.. ##::: ##. ####:: ##:: ##. ####: ##::: ##:::::::::::::::::::::::
::::::::::::::::::::::: ##: ##: ##: ##.... ##: ##::. ##:: ##:. ###:: ##:: ##:. ###: ##::: ##:::::::::::::::::::::::
:::::::::::::::::::::::. ###. ###:: ##:::: ##: ##:::. ##: ##::. ##:'####: ##::. ##:. ######::::::::::::::::::::::::
::::::::::::::::::::::::...::...:::..:::::..::..:::::..::..::::..::....::..::::..:::......:::::::::::::::::::::::::
#+END_SRC

Code in this section is under construction.  Most likely broken.

* EOF

# End of document.

# The following adds some space at the bottom of exported HTML
#+HTML: <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br />
#+HTML: <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br />
#+HTML: <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br />
#+HTML: <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br />
#+HTML: <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br />
